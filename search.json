[{"title":"单例模式的终极实现方案","url":"http://yoursite.com/2017/10/12/【设计模式】单例模式的终极实现方案/","content":"<p>单例模式（Singleton）是一种使用率非常高的设计模式，其主要目的在于保证某一类在运行期间仅被创建一个实例，并为该实例提供了一个全局访问方法，通常命名为getInstance()方法。单例模式的本质简言之即是：</p>\n<center><strong>控制实例数目</strong></center>\n\n<p>以Java为例，单例模式通常可分为<strong>饿汉式</strong>和<strong>懒汉式</strong>两种常规实现方式</p>\n<h1 id=\"饿汉式单例实现\"><a href=\"#饿汉式单例实现\" class=\"headerlink\" title=\"饿汉式单例实现\"></a>饿汉式单例实现</h1><p>饿汉式顾名思义，就是对类实例（食物？）的需求非常强烈，因此，在装载该单例类的时候就会创建类实例。如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 装载时即创建类实例，并保存在类变量instance中</span></div><div class=\"line\"><span class=\"comment\">     * 加上static关键词使得该变量能在getInstance()静态方法中使用</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 加上static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  由于类实例在类装载时已被创建并保存在instance中，因此可直接返回</span></div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上，在Android开发中，Android Studio提供了一个直接创建单例类的功能（File-&gt;new-&gt;Singleton），该功能自动生成的单例类正是采用了饿汉式的实现方式</p>\n<h1 id=\"懒汉式单例实现\"><a href=\"#懒汉式单例实现\" class=\"headerlink\" title=\"懒汉式单例实现\"></a>懒汉式单例实现</h1><p>说到懒，我们自然而然会想到拖延症这一恶习，这一点和懒汉式的单例实现方式相似，这一实现方式会一直等到真正需要使用对象实例的时候再去创建该实例。如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 装载时不创建类实例，但需要利用一个类变量去保存后续创建的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得该变量能在getInstance()静态方法中使用</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  如果instance未被初始化，则初始化该类实例</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上，虽然我们前面拿拖延症来与懒汉式做类比，但懒汉式的拖延却是实际开发中的一种较为常见的节省资源的方式，即<strong>延迟加载</strong>思想。这一思想的核心在于直到需要使用某些资源或数据时再去加载该资源或获取该数据，这样可以尽可能地节省使用前的内存空间</p>\n<h1 id=\"线程安全的懒汉式单例实现\"><a href=\"#线程安全的懒汉式单例实现\" class=\"headerlink\" title=\"线程安全的懒汉式单例实现\"></a>线程安全的懒汉式单例实现</h1><p>不难分析出，当外部多个线程同时想要获取单例类实例时，上述懒汉式实现方式便很容易导致并发问题。通常有如下几种改进方式</p>\n<h2 id=\"添加synchronized关键词\"><a href=\"#添加synchronized关键词\" class=\"headerlink\" title=\"添加synchronized关键词\"></a>添加synchronized关键词</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">....</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>这种改进方式是最简单的，但由于外部每次调用getInstance()方法时均需进行判断，因此该方式也是效率较低的</p>\n<h2 id=\"利用双重检查加锁机制\"><a href=\"#利用双重检查加锁机制\" class=\"headerlink\" title=\"利用双重检查加锁机制\"></a>利用双重检查加锁机制</h2><p>双重检查加锁机制分为如下两重检查</p>\n<ul>\n<li>在程序每次调用getInstance()方法时先不进行同步，而是在进入该方法后再去检查类实例是否存在，若不存在则进入接下来的同步代码块</li>\n<li>进入同步代码块后将再次检查类实例是否存在，若不存在则创建一个新的实例</li>\n</ul>\n<p>这样一来，就只需要在类实例初始化时进行一次同步判断即可，而非每次调用getInstance()方法时都进行同步判断，大大节省了时间，具体实现如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 装载时不创建类实例，但需要利用一个类变量去保存后续创建的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 添加volatile关键词使其不会被本地线程缓存，保证线程能正确处理</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得该变量能在getInstance()静态方法中使用</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  第一重检查：如果instance未被初始化，则进入同步代码块</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//  同步代码块，保证线程安全</span></div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">                <span class=\"comment\">//  第二重检查：如果instance未被初始化，则初始化该类实例</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"利用Java缓存思想实现的单例实现\"><a href=\"#利用Java缓存思想实现的单例实现\" class=\"headerlink\" title=\"利用Java缓存思想实现的单例实现\"></a>利用Java缓存思想实现的单例实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//  类实例缓存KEY值</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY = <span class=\"string\">\"CACHE\"</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  类实例缓存容器</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, Singleton&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  尝试从缓存容器中获取类实例</span></div><div class=\"line\">        Singleton instance = map.get(KEY);</div><div class=\"line\">        <span class=\"comment\">//  未能获取类实例，则初始化该实例，并将其缓存至容器中</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            map.put(KEY, instance);</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述实现方式暂未考虑线程安全问题。事实上，利用缓存来实现的单例模式其最大的优点在于对单例模式进行扩展。我们自然而然地可以想到这么一种情况，既然在实际开发中经常需要保证某个类只能被创建一个实例，那么，会不会出现保证某个类只能被创建两个或多个实例这种需求呢？对于这项需求，我们首先可以想到，上述实现方式中所建立的缓存容器是可以存储多个类实例的，利用这一特点，只需考虑一个问题，即外部调用时到底需要为其返回哪一个实例，便可实现<strong>“双例模式”</strong>以及<strong>“多例模式”</strong>（原谅我为它们取了一些奇怪的名字）了，具体实现如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//  可创建的最大类实例数，这里以“双例模式”为例</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  类实例缓存KEY值</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY = <span class=\"string\">\"CACHE\"</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  当前正在使用的实例序号</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> index = <span class=\"number\">1</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  类实例缓存容器</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, Singleton&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  尝试从缓存容器中获取第index个类实例</span></div><div class=\"line\">        String key = KEY + index;</div><div class=\"line\">        Singleton instance = map.get(key);</div><div class=\"line\">        <span class=\"comment\">//  未能获取类实例，则初始化该实例，并将其缓存至容器相应index中</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            map.put(key, instance);</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\">//  这里以最基本的顺序调用为例，其他复杂调度方式不加讨论，具体调用方式如下</span></div><div class=\"line\">        <span class=\"comment\">//  index++，以在下一次调用中获取下一个类实例，当达到类实例数上限时，重新获取第一个类实例</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((++index) &gt; MAX) &#123;</div><div class=\"line\">            index = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"单例模式的最佳实现\"><a href=\"#单例模式的最佳实现\" class=\"headerlink\" title=\"单例模式的最佳实现\"></a>单例模式的最佳实现</h1><p>综合而言，上述实现方式都或多或少地存在诸如线程不安全、无法做到延迟加载等小缺陷。这里给出一个可以称得上完美的最佳解决方案</p>\n<center><strong>Lazy Initialization Holder Class 模式</strong></center>\n\n<p>这一方案的核心在于Java的<strong>类级内部类</strong>（即使用static关键词修饰的内部类，否则称之为对象级内部类）以及<strong>多线程缺省同步锁</strong>，先来看看具体实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类级内部类，用于缓存类实例</span></div><div class=\"line\"><span class=\"comment\">     * 该类将在被调用时才会被装载，从而实现了延迟加载</span></div><div class=\"line\"><span class=\"comment\">     * 同时由于instance采用静态初始化的方式，因此JVM能保证其线程安全性</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instance</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Instance.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在前面提到的饿汉式实现方式中，我们利用Java的静态初始化、借由JVM实现了线程安全，因此这里同样采用了这种方式。而另一方面，为了避免饿汉式实现中无法进行延迟加载的缺陷，我们构造了一个类级内部类来缓存类实例，由于该类只会在通过getInstance()方法去调用时才会被系统装载，换言之，只有初次调用getInstance()方法时才会去初始化类实例，因此也实现了延迟加载这一功能。如此便可使得这一实现方式能够同时具备线程安全、延迟加载以及节省大量同步判断资源等优势，可以说是单例模式的最佳实现了</p>\n","categories":["设计模式"],"tags":["Android","设计模式","Java","线程安全"]},{"title":"解决ScrollView嵌套RecyclerView的显示及滑动问题","url":"http://yoursite.com/2017/10/10/【Android】解决ScrollView嵌套RecyclerView导致的显示、高度及滑动卡顿问题/","content":"<p>项目中时常需要实现在ScrollView中嵌入一个或多个RecyclerView。这一做法通常会导致如下几个问题</p>\n<ul>\n<li>页面滑动卡顿</li>\n<li>ScrollView高度显示不正常</li>\n<li>RecyclerView内容显示不全</li>\n</ul>\n<p>本文将利用多种方式分别解决上述问题</p>\n<h1 id=\"滑动卡顿解决方案\"><a href=\"#滑动卡顿解决方案\" class=\"headerlink\" title=\"滑动卡顿解决方案\"></a>滑动卡顿解决方案</h1><p>若只存在滑动卡顿这一问题，可以采用如下两种简单方式快速解决</p>\n<h2 id=\"利用RecyclerView内部方法\"><a href=\"#利用RecyclerView内部方法\" class=\"headerlink\" title=\"利用RecyclerView内部方法\"></a>利用RecyclerView内部方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerView.setHasFixedSize(<span class=\"keyword\">true</span>);</div><div class=\"line\">recyclerView.setNestedScrollingEnabled(<span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>其中，setHasFixedSize(true)方法使得RecyclerView能够固定自身size不受adapter变化的影响；而setNestedScrollingeEnabled(false)方法则是进一步调用了RecyclerView内部NestedScrollingChildHelper对象的setNestedScrollingeEnabled(false)方法，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNestedScrollingEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span> enabled)</span> </span>&#123;</div><div class=\"line\">    getScrollingChildHelper().setNestedScrollingEnabled(enabled);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进而，NestedScrollingChildHelper对象通过该方法关闭RecyclerView的嵌套滑动特性，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNestedScrollingEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span> enabled)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mIsNestedScrollingEnabled) &#123;</div><div class=\"line\">        ViewCompat.stopNestedScroll(mView);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mIsNestedScrollingEnabled = enabled;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如此一来，限制了RecyclerView自身的滑动，整个页面滑动仅依靠ScrollView实现，即可解决滑动卡顿的问题</p>\n<h2 id=\"重写LayoutManager\"><a href=\"#重写LayoutManager\" class=\"headerlink\" title=\"重写LayoutManager\"></a>重写LayoutManager</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">LinearLayoutManager linearLayoutManager = <span class=\"keyword\">new</span> LinearLayoutManager(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canScrollVertically</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这一方式使得RecyclerView的垂直滑动始终返回false，其目的同样是为了限制自身的滑动</p>\n<h1 id=\"综合解决方案\"><a href=\"#综合解决方案\" class=\"headerlink\" title=\"综合解决方案\"></a>综合解决方案</h1><p>若是需要综合解决上述三个问题，则可以采用如下几种方式</p>\n<h2 id=\"插入LinearLayout-RelativeLayout\"><a href=\"#插入LinearLayout-RelativeLayout\" class=\"headerlink\" title=\"插入LinearLayout/RelativeLayout\"></a>插入LinearLayout/RelativeLayout</h2><p>在原有布局中插入一层LinearLayout/RelativeLayout，形成如下布局</p>\n<center><img src=\"/img/1.png\" alt=\"\"></center>\n\n<h2 id=\"重写LayoutManager-1\"><a href=\"#重写LayoutManager-1\" class=\"headerlink\" title=\"重写LayoutManager\"></a>重写LayoutManager</h2><p>该方法的核心思想在于通过重写LayoutManager中的onMeasure()方法，即</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(RecyclerView.Recycler recycler, RecyclerView.State state, <span class=\"keyword\">int</span> widthSpec, <span class=\"keyword\">int</span> heightSpec)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(recycler, state, widthSpec, heightSpec);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重新实现RecyclerView高度的计算，使得其能够在ScrollView中表现出正确的高度，具体重写方式可参考这篇文章</p>\n<p><a href=\"http://www.cnblogs.com/tianzhijiexian/p/4469516.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/tianzhijiexian/p/4469516.html</a></p>\n<h2 id=\"重写ScrollView\"><a href=\"#重写ScrollView\" class=\"headerlink\" title=\"重写ScrollView\"></a>重写ScrollView</h2><p>该方法的核心思想在于通过重写ScrollView的onInterceptTouchEvent(MotionEvent ev)方法，拦截滑动事件，使得滑动事件能够直接传递给RecyclerView，具体重写方式可参考如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * Created by YH on 2017/10/10.</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecyclerScrollView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ScrollView</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> slop;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> touch;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RecyclerScrollView</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context);</div><div class=\"line\">        setSlop(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RecyclerScrollView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        setSlop(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RecyclerScrollView</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</div><div class=\"line\">        setSlop(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 是否intercept当前的触摸事件</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ev 触摸事件</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true：调用onMotionEvent()方法，并完成滑动操作</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (ev.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">                <span class=\"comment\">//  保存当前touch的纵坐标值</span></div><div class=\"line\">                touch = (<span class=\"keyword\">int</span>) ev.getRawY();</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">                <span class=\"comment\">//  滑动距离大于slop值时，返回true</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (Math.abs((<span class=\"keyword\">int</span>) ev.getRawY() - touch) &gt; slop) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(ev);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 获取相应context的touch slop值（即在用户滑动之前，能够滑动的以像素为单位的距离）</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context ScrollView对应的context</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setSlop</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        slop = ViewConfiguration.get(context).getScaledTouchSlop();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上，尽管我们能够采用多种方式解决ScrollView嵌套RecyclerView所产生的一系列问题，但由于上述解决方式均会使得RecyclerView在页面加载过程中一次性显示所有内容，因此当RecyclerView下的条目过多时，将会对影响整个应用的运行效率。基于此，在这种情况下我们应当尽量避免采用ScrollView嵌套RecyclerView的布局方式</p>\n","categories":["Android"],"tags":["Android","自定控件"]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]}]