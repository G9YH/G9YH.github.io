[{"title":"重写GridView实现仿今日头条的频道编辑页(1)","url":"http://yoursite.com/2017/10/17/【Android】重写GridView实现仿今日头条的频道编辑页(1)/","content":"<p>本文旨在通过<strong>重写GridView</strong>，配合<strong>系统弹窗</strong>实现仿今日头条的频道编辑页面</p>\n<p>注：由于代码稍长，本文仅列出关键部分，完整工程请参见【<a href=\"https://github.com/G9YH/YHChannelEdit\" target=\"_blank\" rel=\"external\">https://github.com/G9YH/YHChannelEdit</a>】</p>\n<p>在开始讲解盗版的实现方案前，让我们先来看看正版与盗版的实际使用效果对比，首先是正版</p>\n<center><img src=\"/img/2.gif\" alt=\"\"></center>\n\n<p>接下来是盗版</p>\n<center><img src=\"/img/3.gif\" alt=\"\"></center>\n\n<p>当然，在部分视图的设计方面还是存在着不小的差异的，但这一页面大部分基本功能已然实现了。那么接下来，就让我们开始我们的模仿秀</p>\n<h1 id=\"实现思想\"><a href=\"#实现思想\" class=\"headerlink\" title=\"实现思想\"></a>实现思想</h1><p>事实上，我的频道列表中，如何实现长按拖拽并交换频道位置是整个页面的核心难点。大致实现思路如下</p>\n<ul>\n<li>长按某个频道后，在该频道上方生成一个与之相同的弹窗，同时隐藏该频道视图</li>\n<li>当手指按下时，该弹窗跟随触摸点移动</li>\n<li>弹窗移动过程中，根据触摸点交换其他频道位置</li>\n<li>当手指抬起时，在触摸点当前对应的位置处生成一个与弹窗相同的频道视图</li>\n</ul>\n<p>抛开这一问题，其余部分的实现逻辑都较为简单，这里不再赘述，下文将更会有具体实现的介绍</p>\n<h1 id=\"实现要点\"><a href=\"#实现要点\" class=\"headerlink\" title=\"实现要点\"></a>实现要点</h1><h2 id=\"我的频道\"><a href=\"#我的频道\" class=\"headerlink\" title=\"我的频道\"></a>我的频道</h2><p>正如前文所言，这一部分的核心在于<strong>重写GridView</strong>以及<strong>系统弹窗</strong>，那么，首先自然是系统弹窗权限的开启</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;uses-permission android:name=<span class=\"string\">\"android.permission.SYSTEM_ALERT_WINDOW\"</span> /&gt;</div></pre></td></tr></table></figure>\n<p>接下来即是GridView的重写。首先定义了两个常量用户标识当前的模式，即编辑模式和普通模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MODE_EDIT = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MODE_NORMAL = <span class=\"number\">2</span>;</div></pre></td></tr></table></figure>\n<p>然后实现了OnItemLongClickListener接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onItemLongClick</span><span class=\"params\">(AdapterView&lt;?&gt; adapterView, View view, <span class=\"keyword\">int</span> i, <span class=\"keyword\">long</span> l)</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//  已处于移动模式</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (mode == MODE_EDIT) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    textEdit.setText(<span class=\"string\">\"完成\"</span>);</div><div class=\"line\"> </div><div class=\"line\">    ....</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  推荐标签无法移动或删除</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  判断并获取弹窗权限</span></div><div class=\"line\">    permissionGetter.alertWindowPermissionRequest();</div><div class=\"line\"> </div><div class=\"line\">    ....</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  初始化弹窗</span></div><div class=\"line\">    initWindow();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里需要注意到的是PermissionGetter类，我们知道，尽管在manifests中定义了系统弹窗的权限，但通常而言手机是需要用户手动为app开启相关权限的。PermissionGetter类的作用即在于此，该类通过分别处理小米、魅族以及华为等几个较为特殊的Android系统，基本实现了大部分机型的弹窗权限申请功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 判断系统是否已为应用开启某项权限</span></div><div class=\"line\"><span class=\"comment\"> *</span></div><div class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> num 权限编号</span></div><div class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 已开启则返回0，否则返回1</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">checkPermission</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> version = Build.VERSION.SDK_INT;</div><div class=\"line\">    <span class=\"keyword\">if</span> (version &gt;= <span class=\"number\">19</span>) &#123;</div><div class=\"line\">        ....</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">....</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * Android 6.0之后的手机需要进行弹窗权限的申请</span></div><div class=\"line\"><span class=\"comment\"> * 其中小米、魅族以及华为三种机型需要特殊处理</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">alertWindowPermission</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.checkPermission(<span class=\"number\">24</span>) == <span class=\"number\">1</span>) &#123;</div><div class=\"line\">        Toast toast = Toast.makeText(</div><div class=\"line\">                context, <span class=\"string\">\"请先为您的手机开启悬浮窗权限\"</span>, Toast.LENGTH_SHORT);</div><div class=\"line\">        toast.show();</div><div class=\"line\">        <span class=\"comment\">//  处理小米手机权限</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">\"Xiaomi\"</span>.equals(Build.MANUFACTURER)) &#123;</div><div class=\"line\">            ....</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//  处理魅族手机权限</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"Meizu\"</span>.equals(Build.MANUFACTURER)) &#123;</div><div class=\"line\">            ....</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//  处理华为手机权限</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"Huawei\"</span>.equals(Build.MANUFACTURER)) &#123;</div><div class=\"line\">            ....</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//  处理其他手机权限</span></div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">23</span>) &#123;</div><div class=\"line\">            ....</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在长按接口中实现了弹窗的初始化后，将模式mode设置为MODE_EDIT。此时即可通过重写onTouchEvent(MovtionEvent motionEvent)方法来判断何时进行弹窗的更新以及关闭等工作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent motionEvent)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (motionEvent.getAction()) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">            <span class=\"keyword\">if</span> (mode == MODE_EDIT) &#123;</div><div class=\"line\">                updateWindow(motionEvent);</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</div><div class=\"line\">            <span class=\"keyword\">if</span> (mode == MODE_EDIT) &#123;</div><div class=\"line\">                closeWindow();</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onTouchEvent(motionEvent);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当手指按下时，持续更新弹窗位置，并根据其位置交换其他频道的位置，当然不要忘记了交换动作相应的动画</p>\n<p>当手指抬起时，将模式mode设置为MODE_NORMAL，并在弹窗当前对应的频道处生成一个与弹窗相同的视图，同时移除该弹窗视图即可</p>\n<h2 id=\"频道推荐\"><a href=\"#频道推荐\" class=\"headerlink\" title=\"频道推荐\"></a>频道推荐</h2><p>这一部分的实现就较为简单了，只需利用GridView展示频道，然后实现OnItemClickListener接口，点击时将该item移除并添加至我的频道视图中即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@OnItemClick</span>(R.id.grid_recommend) <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">gridRecommend</span><span class=\"params\">(<span class=\"keyword\">int</span> position)</span> </span>&#123;</div><div class=\"line\">    String string = listHolder.getRecommendList().get(position);</div><div class=\"line\">    <span class=\"comment\">//  我的频道中增加标签</span></div><div class=\"line\">    listHolder.getMineList().add(string);</div><div class=\"line\">    <span class=\"comment\">//  频道推荐中删除标签</span></div><div class=\"line\">    listHolder.getRecommendList().remove(position);</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  更新各频道数据</span></div><div class=\"line\">    mineAdapter.moveNotifyDataSetChanged(<span class=\"keyword\">false</span>, -<span class=\"number\">1</span>);</div><div class=\"line\">    recommendAdapter.notifyDataSetChanged();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"列表缓存\"><a href=\"#列表缓存\" class=\"headerlink\" title=\"列表缓存\"></a>列表缓存</h2><p>事实上，在实际开发中，通常可以采用SharedPreferences配合服务器端来实现我的频道以及频道推荐两个列表内容的持久化存储。但由于这里仅仅是实现一个demo，因此存储功能仅通过一个单例类ListHolder来模拟实现。其中ListHolder单例的实现方式如下，参考了我之前的一篇博客<a href=\"https://g9yh.github.io/2017/10/12/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/\" target=\"_blank\" rel=\"external\">《单例模式的终极实现方案》</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListHolder</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; mineList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; recommendList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instance</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ListHolder instance = <span class=\"keyword\">new</span> ListHolder();</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ListHolder</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListHolder <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Instance.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">get</span><span class=\"params\">()</span> &amp; <span class=\"title\">set</span><span class=\"params\">()</span></span></div><div class=\"line\"><span class=\"function\">&#125;</span></div></pre></td></tr></table></figure>\n<h1 id=\"优化改进\"><a href=\"#优化改进\" class=\"headerlink\" title=\"优化改进\"></a>优化改进</h1><p>尽管到目前为止，我们已经实现了大部分的基本功能，但仍与正版有部分差异，例如频道列表内容的存储、部分动画的实现以及视图设计的差别等等，这一系列问题都将在之后的开发工作中继续优化</p>\n","categories":["Android"],"tags":["Android","自定控件"]},{"title":"单例模式的终极实现方案","url":"http://yoursite.com/2017/10/12/【设计模式】单例模式的终极实现方案/","content":"<p>单例模式（Singleton）是一种使用率非常高的设计模式，其主要目的在于保证某一类在运行期间仅被创建一个实例，并为该实例提供了一个全局访问方法，通常命名为getInstance()方法。单例模式的本质简言之即是：</p>\n<center><strong>控制实例数目</strong></center>\n\n<p>以Java为例，单例模式通常可分为<strong>饿汉式</strong>和<strong>懒汉式</strong>两种常规实现方式</p>\n<h1 id=\"饿汉式单例实现\"><a href=\"#饿汉式单例实现\" class=\"headerlink\" title=\"饿汉式单例实现\"></a>饿汉式单例实现</h1><p>饿汉式顾名思义，就是对类实例（食物？）的需求非常强烈，因此，在装载该单例类的时候就会创建类实例。如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 装载时即创建类实例，并保存在类变量instance中</span></div><div class=\"line\"><span class=\"comment\">     * 加上static关键词使得该变量能在getInstance()静态方法中使用</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 加上static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  由于类实例在类装载时已被创建并保存在instance中，因此可直接返回</span></div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上，在Android开发中，Android Studio提供了一个直接创建单例类的功能（File-&gt;new-&gt;Singleton），该功能自动生成的单例类正是采用了饿汉式的实现方式</p>\n<h1 id=\"懒汉式单例实现\"><a href=\"#懒汉式单例实现\" class=\"headerlink\" title=\"懒汉式单例实现\"></a>懒汉式单例实现</h1><p>说到懒，我们自然而然会想到拖延症这一恶习，这一点和懒汉式的单例实现方式相似，这一实现方式会一直等到真正需要使用对象实例的时候再去创建该实例。如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 装载时不创建类实例，但需要利用一个类变量去保存后续创建的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得该变量能在getInstance()静态方法中使用</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  如果instance未被初始化，则初始化该类实例</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上，虽然我们前面拿拖延症来与懒汉式做类比，但懒汉式的拖延却是实际开发中的一种较为常见的节省资源的方式，即<strong>延迟加载</strong>思想。这一思想的核心在于直到需要使用某些资源或数据时再去加载该资源或获取该数据，这样可以尽可能地节省使用前的内存空间</p>\n<h1 id=\"线程安全的懒汉式单例实现\"><a href=\"#线程安全的懒汉式单例实现\" class=\"headerlink\" title=\"线程安全的懒汉式单例实现\"></a>线程安全的懒汉式单例实现</h1><p>不难分析出，当外部多个线程同时想要获取单例类实例时，上述懒汉式实现方式便很容易导致并发问题。通常有如下几种改进方式</p>\n<h2 id=\"添加synchronized关键词\"><a href=\"#添加synchronized关键词\" class=\"headerlink\" title=\"添加synchronized关键词\"></a>添加synchronized关键词</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">....</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">....</div></pre></td></tr></table></figure>\n<p>这种改进方式是最简单的，但由于外部每次调用getInstance()方法时均需进行判断，因此该方式也是效率较低的</p>\n<h2 id=\"利用双重检查加锁机制\"><a href=\"#利用双重检查加锁机制\" class=\"headerlink\" title=\"利用双重检查加锁机制\"></a>利用双重检查加锁机制</h2><p>双重检查加锁机制分为如下两重检查</p>\n<ul>\n<li>在程序每次调用getInstance()方法时先不进行同步，而是在进入该方法后再去检查类实例是否存在，若不存在则进入接下来的同步代码块</li>\n<li>进入同步代码块后将再次检查类实例是否存在，若不存在则创建一个新的实例</li>\n</ul>\n<p>这样一来，就只需要在类实例初始化时进行一次同步判断即可，而非每次调用getInstance()方法时都进行同步判断，大大节省了时间，具体实现如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 装载时不创建类实例，但需要利用一个类变量去保存后续创建的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 添加volatile关键词使其不会被本地线程缓存，保证线程能正确处理</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得该变量能在getInstance()静态方法中使用</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  第一重检查：如果instance未被初始化，则进入同步代码块</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            <span class=\"comment\">//  同步代码块，保证线程安全</span></div><div class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</div><div class=\"line\">                <span class=\"comment\">//  第二重检查：如果instance未被初始化，则初始化该类实例</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">                    instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"利用Java缓存思想实现的单例实现\"><a href=\"#利用Java缓存思想实现的单例实现\" class=\"headerlink\" title=\"利用Java缓存思想实现的单例实现\"></a>利用Java缓存思想实现的单例实现</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//  类实例缓存KEY值</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY = <span class=\"string\">\"CACHE\"</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  类实例缓存容器</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, Singleton&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  尝试从缓存容器中获取类实例</span></div><div class=\"line\">        Singleton instance = map.get(KEY);</div><div class=\"line\">        <span class=\"comment\">//  未能获取类实例，则初始化该实例，并将其缓存至容器中</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            map.put(KEY, instance);</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述实现方式暂未考虑线程安全问题。事实上，利用缓存来实现的单例模式其最大的优点在于对单例模式进行扩展。我们自然而然地可以想到这么一种情况，既然在实际开发中经常需要保证某个类只能被创建一个实例，那么，会不会出现保证某个类只能被创建两个或多个实例这种需求呢？对于这项需求，我们首先可以想到，上述实现方式中所建立的缓存容器是可以存储多个类实例的，利用这一特点，只需考虑一个问题，即外部调用时到底需要为其返回哪一个实例，便可实现<strong>“双例模式”</strong>以及<strong>“多例模式”</strong>（原谅我为它们取了一些奇怪的名字）了，具体实现如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//  可创建的最大类实例数，这里以“双例模式”为例</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">2</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  类实例缓存KEY值</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String KEY = <span class=\"string\">\"CACHE\"</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  当前正在使用的实例序号</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> index = <span class=\"number\">1</span>;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">//  类实例缓存容器</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, Singleton&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//  尝试从缓存容器中获取第index个类实例</span></div><div class=\"line\">        String key = KEY + index;</div><div class=\"line\">        Singleton instance = map.get(key);</div><div class=\"line\">        <span class=\"comment\">//  未能获取类实例，则初始化该实例，并将其缓存至容器相应index中</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">            map.put(key, instance);</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\">//  这里以最基本的顺序调用为例，其他复杂调度方式不加讨论，具体调用方式如下</span></div><div class=\"line\">        <span class=\"comment\">//  index++，以在下一次调用中获取下一个类实例，当达到类实例数上限时，重新获取第一个类实例</span></div><div class=\"line\">        <span class=\"keyword\">if</span> ((++index) &gt; MAX) &#123;</div><div class=\"line\">            index = <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"单例模式的最佳实现\"><a href=\"#单例模式的最佳实现\" class=\"headerlink\" title=\"单例模式的最佳实现\"></a>单例模式的最佳实现</h1><p>综合而言，上述实现方式都或多或少地存在诸如线程不安全、无法做到延迟加载等小缺陷。这里给出一个可以称得上完美的最佳解决方案</p>\n<center><strong>Lazy Initialization Holder Class 模式</strong></center>\n\n<p>这一方案的核心在于Java的<strong>类级内部类</strong>（即使用static关键词修饰的内部类，否则称之为对象级内部类）以及<strong>多线程缺省同步锁</strong>，先来看看具体实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类级内部类，用于缓存类实例</span></div><div class=\"line\"><span class=\"comment\">     * 该类将在被调用时才会被装载，从而实现了延迟加载</span></div><div class=\"line\"><span class=\"comment\">     * 同时由于instance采用静态初始化的方式，因此JVM能保证其线程安全性</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instance</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 私有化构造方法，使外部无法通过构造方法构造除instance外的类实例</span></div><div class=\"line\"><span class=\"comment\">     * 从而达到单例模式控制类实例数目的目的</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 类实例的全局访问方法</span></div><div class=\"line\"><span class=\"comment\">     * 添加static关键词使得外部可以通过类名直接调用该方法获取类实例</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 单例类实例</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Instance.instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在前面提到的饿汉式实现方式中，我们利用Java的静态初始化、借由JVM实现了线程安全，因此这里同样采用了这种方式。而另一方面，为了避免饿汉式实现中无法进行延迟加载的缺陷，我们构造了一个类级内部类来缓存类实例，由于该类只会在通过getInstance()方法去调用时才会被系统装载，换言之，只有初次调用getInstance()方法时才会去初始化类实例，因此也实现了延迟加载这一功能。如此便可使得这一实现方式能够同时具备线程安全、延迟加载以及节省大量同步判断资源等优势，可以说是单例模式的最佳实现了</p>\n","categories":["设计模式"],"tags":["设计模式","Android","Java","线程安全"]},{"title":"解决ScrollView嵌套RecyclerView的显示及滑动问题","url":"http://yoursite.com/2017/10/10/【Android】解决ScrollView嵌套RecyclerView导致的显示、高度及滑动卡顿问题/","content":"<p>项目中时常需要实现在ScrollView中嵌入一个或多个RecyclerView。这一做法通常会导致如下几个问题</p>\n<ul>\n<li>页面滑动卡顿</li>\n<li>ScrollView高度显示不正常</li>\n<li>RecyclerView内容显示不全</li>\n</ul>\n<p>本文将利用多种方式分别解决上述问题</p>\n<h1 id=\"滑动卡顿解决方案\"><a href=\"#滑动卡顿解决方案\" class=\"headerlink\" title=\"滑动卡顿解决方案\"></a>滑动卡顿解决方案</h1><p>若只存在滑动卡顿这一问题，可以采用如下两种简单方式快速解决</p>\n<h2 id=\"利用RecyclerView内部方法\"><a href=\"#利用RecyclerView内部方法\" class=\"headerlink\" title=\"利用RecyclerView内部方法\"></a>利用RecyclerView内部方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">recyclerView.setHasFixedSize(<span class=\"keyword\">true</span>);</div><div class=\"line\">recyclerView.setNestedScrollingEnabled(<span class=\"keyword\">false</span>);</div></pre></td></tr></table></figure>\n<p>其中，setHasFixedSize(true)方法使得RecyclerView能够固定自身size不受adapter变化的影响；而setNestedScrollingeEnabled(false)方法则是进一步调用了RecyclerView内部NestedScrollingChildHelper对象的setNestedScrollingeEnabled(false)方法，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNestedScrollingEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span> enabled)</span> </span>&#123;</div><div class=\"line\">    getScrollingChildHelper().setNestedScrollingEnabled(enabled);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进而，NestedScrollingChildHelper对象通过该方法关闭RecyclerView的嵌套滑动特性，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNestedScrollingEnabled</span><span class=\"params\">(<span class=\"keyword\">boolean</span> enabled)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (mIsNestedScrollingEnabled) &#123;</div><div class=\"line\">        ViewCompat.stopNestedScroll(mView);</div><div class=\"line\">    &#125;</div><div class=\"line\">    mIsNestedScrollingEnabled = enabled;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如此一来，限制了RecyclerView自身的滑动，整个页面滑动仅依靠ScrollView实现，即可解决滑动卡顿的问题</p>\n<h2 id=\"重写LayoutManager\"><a href=\"#重写LayoutManager\" class=\"headerlink\" title=\"重写LayoutManager\"></a>重写LayoutManager</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">LinearLayoutManager linearLayoutManager = <span class=\"keyword\">new</span> LinearLayoutManager(<span class=\"keyword\">this</span>) &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canScrollVertically</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这一方式使得RecyclerView的垂直滑动始终返回false，其目的同样是为了限制自身的滑动</p>\n<h1 id=\"综合解决方案\"><a href=\"#综合解决方案\" class=\"headerlink\" title=\"综合解决方案\"></a>综合解决方案</h1><p>若是需要综合解决上述三个问题，则可以采用如下几种方式</p>\n<h2 id=\"插入LinearLayout-RelativeLayout\"><a href=\"#插入LinearLayout-RelativeLayout\" class=\"headerlink\" title=\"插入LinearLayout/RelativeLayout\"></a>插入LinearLayout/RelativeLayout</h2><p>在原有布局中插入一层LinearLayout/RelativeLayout，形成如下布局</p>\n<center><img src=\"/img/1.png\" alt=\"\"></center>\n\n<h2 id=\"重写LayoutManager-1\"><a href=\"#重写LayoutManager-1\" class=\"headerlink\" title=\"重写LayoutManager\"></a>重写LayoutManager</h2><p>该方法的核心思想在于通过重写LayoutManager中的onMeasure()方法，即</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(RecyclerView.Recycler recycler, RecyclerView.State state, <span class=\"keyword\">int</span> widthSpec, <span class=\"keyword\">int</span> heightSpec)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(recycler, state, widthSpec, heightSpec);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>重新实现RecyclerView高度的计算，使得其能够在ScrollView中表现出正确的高度，具体重写方式可参考这篇文章</p>\n<p><a href=\"http://www.cnblogs.com/tianzhijiexian/p/4469516.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/tianzhijiexian/p/4469516.html</a></p>\n<h2 id=\"重写ScrollView\"><a href=\"#重写ScrollView\" class=\"headerlink\" title=\"重写ScrollView\"></a>重写ScrollView</h2><p>该方法的核心思想在于通过重写ScrollView的onInterceptTouchEvent(MotionEvent ev)方法，拦截滑动事件，使得滑动事件能够直接传递给RecyclerView，具体重写方式可参考如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * Created by YH on 2017/10/10.</span></div><div class=\"line\"><span class=\"comment\"> */</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecyclerScrollView</span> <span class=\"keyword\">extends</span> <span class=\"title\">ScrollView</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> slop;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> touch;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RecyclerScrollView</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context);</div><div class=\"line\">        setSlop(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RecyclerScrollView</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</div><div class=\"line\">        setSlop(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RecyclerScrollView</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</div><div class=\"line\">        setSlop(context);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 是否intercept当前的触摸事件</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ev 触摸事件</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true：调用onMotionEvent()方法，并完成滑动操作</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (ev.getAction()) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</div><div class=\"line\">                <span class=\"comment\">//  保存当前touch的纵坐标值</span></div><div class=\"line\">                touch = (<span class=\"keyword\">int</span>) ev.getRawY();</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</div><div class=\"line\">                <span class=\"comment\">//  滑动距离大于slop值时，返回true</span></div><div class=\"line\">                <span class=\"keyword\">if</span> (Math.abs((<span class=\"keyword\">int</span>) ev.getRawY() - touch) &gt; slop) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(ev);</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">     * 获取相应context的touch slop值（即在用户滑动之前，能够滑动的以像素为单位的距离）</span></div><div class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context ScrollView对应的context</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setSlop</span><span class=\"params\">(Context context)</span> </span>&#123;</div><div class=\"line\">        slop = ViewConfiguration.get(context).getScaledTouchSlop();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>事实上，尽管我们能够采用多种方式解决ScrollView嵌套RecyclerView所产生的一系列问题，但由于上述解决方式均会使得RecyclerView在页面加载过程中一次性显示所有内容，因此当RecyclerView下的条目过多时，将会对影响整个应用的运行效率。基于此，在这种情况下我们应当尽量避免采用ScrollView嵌套RecyclerView的布局方式</p>\n","categories":["Android"],"tags":["Android","自定控件"]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]